<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>策略模式</title>
</head>
<body>

    <form action = "http://www.baidu.com" id="registerForm" method = "post">
        <p>
            <label>请输入用户名：</label>
            <input type="text" name="userName"/>
        </p>
        <p>
            <label>请输入密码：</label>
            <input type="password" name="password"/>
        </p>
        <p>
            <label>请输入手机号码：</label>
            <input type="text" name="phoneNumber"/>
        </p>
        <p>
            <input type="submit" value="我要提交"/>
        </p>
        <textarea name="fala" id="fala" cols="100" rows="5"></textarea>
    </form>
    <script src="../../lib/jquery-1.12.1.min.js"></script>
    <script>
        /*
         策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

         使用策略模式的优点如下：

         优点：1. 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。

         2. 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。

         3. 策略模式中的代码可以复用。

         一：使用策略模式计算奖金；
         */
        var calculateBouns = function(salary,level) {
            if(level === 'A') {
                return salary * 4;
            }
            if(level === 'B') {
                return salary * 3;
            }
            if(level === 'C') {
                return salary * 2;
            }
        };
        // 调用如下：
        console.log(calculateBouns(4000,'A')); // 16000
        console.log(calculateBouns(2500,'B')); // 7500

        /*
         第一个参数为薪资，第二个参数为等级；

         代码缺点如下：

         calculateBouns 函数包含了很多if-else语句。

         calculateBouns 函数缺乏弹性，假如还有D等级的话，那么我们需要在calculateBouns 函数内添加判断等级D的if语句；

         算法复用性差，如果在其他的地方也有类似这样的算法的话，但是规则不一样，我们这些代码不能通用。
         */

//        2. 使用组合函数重构代码
//        组合函数是把各种算法封装到一个个的小函数里面，比如等级A的话，封装一个小函数，等级为B的话，也封装一个小函数，以此类推
        var performanceA = function(salary) {
            return salary * 4;
        };
        var performanceB = function(salary) {
            return salary * 3;
        };

        var performanceC = function(salary) {
            return salary * 2
        };
        var calculateBouns = function(level,salary) {
            if(level === 'A') {
                return performanceA(salary);
            }
            if(level === 'B') {
                return performanceB(salary);
            }
            if(level === 'C') {
                return performanceC(salary);
            }
        };
        // 调用如下
        console.log(calculateBouns('A',4500)); // 18000

//        3. 使用策略模式重构代码
//        策略模式指的是 定义一系列的算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，实际就是将算法的使用和实现分离出来；算法的使用方式是不变的，都是根据某个算法取得计算后的奖金数，而算法的实现是根据绩效对应不同的绩效规则；
//        一个基于策略模式的程序至少由2部分组成，第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，该Context接收客户端的请求，随后把请求委托给某一个策略类。我们先使用传统面向对象来实现；

        var performanceA1 = function(){};
        performanceA1.prototype.calculate = function(salary) {
            return salary * 4;
        };
        var performanceB1 = function(){};
        performanceB1.prototype.calculate = function(salary) {
            return salary * 3;
        };
        var performanceC1 = function(){};
        performanceC1.prototype.calculate = function(salary) {
            return salary * 2;
        };
        // 奖金类
        var Bouns = function(){
            this.salary = null;    // 原始工资
            this.levelObj = null;  // 绩效等级对应的策略对象
        };
        Bouns.prototype.setSalary = function(salary) {
            this.salary = salary;  // 保存员工的原始工资
        };
        Bouns.prototype.setlevelObj = function(levelObj){
            this.levelObj = levelObj;  // 设置员工绩效等级对应的策略对象
        };
        // 取得奖金数
        Bouns.prototype.getBouns = function(){
            // 把计算奖金的操作委托给对应的策略对象
            return this.levelObj.calculate(this.salary);
        };
        var bouns = new Bouns();
        bouns.setSalary(10000);
        bouns.setlevelObj(new performanceA1()); // 设置策略对象
        console.log(bouns.getBouns());  // 40000

        bouns.setlevelObj(new performanceB1()); // 设置策略对象
        console.log(bouns.getBouns());  // 30000

//        4. Javascript版本的策略模式      --这个方法就是那个什么，jq里面用的。用一个数组或者对象保存需要使用的可扩展的方法
        var obj = {
            "A": function(salary) {
                return salary * 4;
            },
            "B" : function(salary) {
                return salary * 3;
            },
            "C" : function(salary) {
                return salary * 2;
            }
        };
        var calculateBouns =function(level,salary) {
            return obj[level](salary);
        };
        console.log(calculateBouns('A',10000)); // 40000
//        策略模式指的是定义一系列的算法，并且把它们封装起来，但是策略模式不仅仅只封装算法，我们还可以对用来封装一系列的业务规则，只要这些业务规则目标一致，我们就可以使用策略模式来封装它们；
    </script>

    <script>
        /*
         表单效验

         比如我们经常来进行表单验证，比如注册登录对话框，我们登录之前要进行验证操作：比如有以下几条逻辑：

         用户名不能为空

         密码长度不能小于6位。

         手机号码必须符合格式。
         */
        //我们正常的编写表单验证代码如下：
        var registerForm = document.getElementById("registerForm");
        console.warn(registerForm);     //这里需要更多的理解一下form这个标签；
        registerForm.onsubmit = function(){
            if(registerForm.userName.value === '') {
                alert('用户名不能为空');
                return;
            }
            if(registerForm.password.value.length < 6) {
                alert("密码的长度不能小于6位");
                return;
            }
            if(!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) {
                alert("手机号码格式不正确");
                return;
            }
        };
        /*
         但是这样编写代码有如下缺点：

         1.registerForm.onsubmit 函数比较大，代码中包含了很多if语句；

         2.registerForm.onsubmit 函数缺乏弹性，如果增加了一种新的效验规则，或者想把密码的长度效验从6改成8，我们必须改registerForm.onsubmit 函数内部的代码。违反了开放-封闭原则。

         3. 算法的复用性差，如果在程序中增加了另外一个表单，这个表单也需要进行一些类似的效验，那么我们可能又需要复制代码了；
         */

        //  使用策略模式来重构表单效验   -----  我的天，这就是策略模式的一个简单例子？ 有意思
        var strategys = {
            isNotEmpty: function(value,errorMsg) {
                if(value === '') {
                    return errorMsg;
                }
            },
            // 限制最小长度
            minLength: function(value,length,errorMsg) {
                if(value.length < length) {
                    return errorMsg;
                }
            },
            // 手机号码格式
            mobileFormat: function(value,errorMsg) {
                if(!/(^1[3|5|8][0-9]{9}$)/.test(value)) {
                    return errorMsg;
                }
            }
        };
        //实现Validator类，Validator类在这里作为Context，负责接收用户的请求并委托给strategy 对象
        var Validator = function(){
            this.cache = [];  // 保存效验规则
        };
        Validator.prototype.add = function(dom,rule,errorMsg) {
            var str = rule.split(":");  //没有 ：就忽略，主要是用来考虑minLength:6 这种情况的
            this.cache.push(function(){
                // str 返回的是 minLength:6
                var strategy = str.shift();
                str.unshift(dom.value); // 把input的value添加进参数列表
                str.push(errorMsg);  // 把errorMsg添加进参数列表
                return strategys[strategy].apply(dom,str);
            });
        };
        Validator.prototype.start = function(){
            for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) {
                var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
                if(msg) {
                    return msg;
                }
            }
        };
        //当我们往validator对象里添加完一系列的效验规则之后，会调用validator.start()方法来启动效验。
        // 如果validator.start()返回了一个errorMsg字符串作为返回值，说明该次效验没有通过，此时需要registerForm.onsubmit方法返回false来阻止表单提交
        var validateFunc = function(){
            var validator = new Validator(); // 创建一个Validator对象
            /* 添加一些效验规则 */
            validator.add(registerForm.userName,'isNotEmpty','用户名不能为空');
            validator.add(registerForm.password,'minLength:6','密码长度不能小于6位');
            validator.add(registerForm.userName,'mobileFormat','手机号码格式不正确');

            var errorMsg = validator.start(); // 获得效验结果
            return errorMsg; // 返回效验结果
        };
        var registerForm = document.getElementById("registerForm");
        registerForm.onsubmit = function(){
            var errorMsg = validateFunc();
            if(errorMsg){
                alert(errorMsg);
                return false;
            }
        };

        // PS：这个真的挺不错的啊。很有学习价值

        // 另： form 标签
        /*
         一个<form>标记，就是一个form对象。

         <Form
         Name ="表单的名称"
         Target ="指定从服务器返回的数据在那里显示"
         action ="指定一个URL，表单数据将被提交给该URL"
         Method =“信息数据传送方式(get/post)”
         enctype ="被提交数据的格式"
         [onsubmit ="JavaScript代码"]>
         </Form>

         form对象的方法
             submit():提交表单
             reset():重置表单

         form对象的事件
             onsubmit：表单提交时发生。一般在表单数据传递到服务器之前。(表单验证多在此时)
             onreset：表单重置时发生。

         表单中通过name属性找对象
             通过name找对象，必须是document开头。
             通过name找对象，必须要符合三层结构。
             格式：document.formObj.elementObj
             参数：formObj代表<form>对象name属性的值。
             elementObj代表<input>对象name属性的值。

         var form = document.forms[0]
         form == document.getElementsByTagName("form")      //false

         Elements外，其它几个均反映了表单中标识中相应属性的状态，这通常是单个表单标识；而elements常
         常是多个表单元素值的数组，例：
         document.forms[0].elements[1]
         document.myform.textField

         还应该去了解 $("form").serialize()  以及 $("form").serializeArray()
         serialize() 方法通过序列化表单值，创建 URL 编码文本字符串。
         您可以选择一个或多个表单元素（比如 input 及/或 文本框），或者 form 元素本身
         如果要表单元素的值包含到序列字符串中，元素必须使用 name 属性。


         */

        /*
         $.param()方法是serialize()方法的核心，用来对一个数组或对象按照key/value进行序列化。
         比如将一个普通的对象序列化：
         var obj = {a:1,b:2,c:3};
         var k = $.param(obj);
         alert(k); //输出a=1&b=2&c=3
         */
    </script>
</body>
</html>