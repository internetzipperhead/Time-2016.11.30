<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>代理模式</title>
</head>
<body>

    <p>
        <label>选择框</label>
        <input type="checkbox" class="j-input" data-id="1"/>
    </p>
    <p>
        <label>选择框</label>
        <input type="checkbox" class="j-input" data-id = "2"/>
    </p>
    <p>
        <label>选择框</label>
        <input type="checkbox" class="j-input" data-id="3"/>
    </p>
    <p>
        <label>选择框</label>
        <input type="checkbox" class="j-input" data-id = "4"/>
    </p>

    <script>
        //代理是一个对象，它可以用来控制对本体对象的访问，它与本体对象实现了同样的接口，
        // 代理对象会把所有的调用方法传递给本体对象的；代理模式最基本的形式是对访问进行控制，
        // 而本体对象则负责执行所分派的那个对象的函数或者类，简单的来讲本地对象注重的去执行页面上的代码，
        // 代理则控制本地对象何时被实例化，何时被使用

        /*代理的优点：

        1、代理对象可以代替本体被实例化，并使其可以被远程访问；
        2、它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，
        或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象；*/

        var girl = function(name){
            this.name = name;
        };
        var gaoFuShuai = function(girl){
            this.girl = girl;
            console.log(girl);
            this.say = function(present){
                console.info(this.girl.name + ' I Love You. 我给您买了一个'+present);
            }
        };
        var proxy = function(girl){
            this.girl = girl;
            this.sendGift = function(gift){
                (new gaoFuShuai(this.girl)).say(gift);
            }
        };
        var leexing = new proxy(new girl("keke"));
        console.log(leexing);
        leexing.sendGift("微笑");

        /*
         理解使用虚拟代理实现图片的预加载
         */
        //第一种方案：不使用代理的预加载图片函数如下 --  个人感觉有点像利用闭包实现的
        var myImage = (function(){
            var imgNode = document.createElement('img');
            document.body.appendChild(imgNode);
            imgNode.id = 'demo';
            var img = new Image();  //这里实例化了一个对象
            img.onload = function(){
                console.info(this)
                imgNode.src = this.src;     // 当img的src加载成功后再用这个img的src去替换 前面网页上显示imgNode的src
            };
            return {
                setSrc: function(src){
                    imgNode.src = "http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif";
                    //img.src = src;
                }
            }
        })();
        //调用
        myImage.setSrc("https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png");

        //使用代理模式来编写预加载图片的代码如下：
        var myImageP = (function(){
            var imgNode = document.createElement("img");
            imgNode.id = "proxy";
            document.body.appendChild(imgNode);
            return {
                setSrc: function(src){
                    imgNode.src = src;
                }
            }
        })();
        var proxyImage = (function(){
            var img = new Image();
            img.onload = function(){
                myImageP.setSrc(this.src);
            };
            return {
                setSrc: function(src){
                    myImageP.setSrc("http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif");
                    img.src = src;
                }
            }
        })();
        proxyImage.setSrc("https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png");

        /*
         他们之间的优缺点如下：

         第一种方案一般的方法代码的耦合性太高，一个函数内负责做了几件事情，比如创建img元素，和实现给未加载图片完成之前设置loading加载状态等多项事情，
         未满足面向对象设计原则中单一职责原则；并且当某个时候不需要代理的时候，需要从myImage 函数内把代码删掉，这样代码耦合性太高。

         第二种方案使用代理模式，其中myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，
         当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可；
         */

    </script>
    //
    <script>
    //虚拟代理实现http请求

    // 本体函数
        var mainFun = function(id){
            console.info(id);
            //下面应该还有一些ajax操作
            //把所有的id一次性发ajax请求给服务器端
        };

    // 代理函数 通过代理函数获取所有的id 传给本体函数去执行
        var proxyFun = (function(){
            var cache = [];     //保存一段时间的id
            var timer = null;   //定时器
            return function(checkboxs){
                if(timer){
                    return;
                }
                timer = setTimeout(function(){
                    // 在2秒内获取所有被选中的id，通过属性isflag判断是否被选中
                    for(var i=0;i<checkboxs.length;i++){
                        if(checkboxs[i].hasAttribute("isflag")){
                            var id = checkboxs[i].getAttribute("data-id");
                            cache.push(id);
                        }
                    }
                    mainFun(cache.join(","));
                    clearTimeout();
                    timer = null;
                    cache = [];
                },2000);
            }
        })();

        var checkboxs = document.getElementsByClassName("j-input");
        for(var i=0;i<checkboxs.length;i++){
            //利用闭包实现i的绑定
            (function(i){
                checkboxs[i].onclick = function(){
                    if(this.checked){
                        this.setAttribute("isflag",1);
                    } else {
                        this.removeAttribute("isflag");
                    }
                    //调用代理模式函数
                    proxyFun(checkboxs)
                }
            })(i);
        }
    </script>
</body>
</html>