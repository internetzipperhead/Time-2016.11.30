<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>发布订阅（观察者）模式</title>
</head>
<body>

<button id="count">点将我</button>

<div id="showcount"></div>

    <script>
        /*
         发布---订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，
         当一个对象发生改变时，所有依赖于它的对象都将得到通知。

         现实生活中的发布-订阅模式；

         比如小红最近在淘宝网上看上一双鞋子，但是呢 联系到卖家后，才发现这双鞋卖光了，但是小红对这双鞋又非常喜欢，所以呢联系卖家，问卖家什么时候有货，卖家告诉她，要等一个星期后才有货，卖家告诉小红，要是你喜欢的话，你可以收藏我们的店铺，等有货的时候再通知你，所以小红收藏了此店铺，但与此同时，小明，小花等也喜欢这双鞋，也收藏了该店铺；等来货的时候就依次会通知他们；
         在上面的故事中，可以看出是一个典型的发布订阅模式，卖家是属于发布者，小红，小明等属于订阅者，订阅该店铺，卖家作为发布者，当鞋子到了的时候，会依次通知小明，小红等，依次使用旺旺等工具给他们发布消息；

         发布订阅模式的优点：

         1. 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。
         比如上面的列子，小明，小红不需要天天逛淘宝网看鞋子到了没有，在合适的时间点，发布者(卖家)来货了的时候，会通知该订阅者(小红，小明等人)。

         2. 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变；同理卖家（发布者）它只需要将鞋子来货的这件事告诉订阅者(买家)，他不管买家到底买还是不买，还是买其他卖家的。只要鞋子到货了就通知订阅者即可。
         对于第一点，我们日常工作中也经常使用到，比如我们的ajax请求，请求有成功(success)和失败(error)的回调函数，我们可以订阅ajax的success和error事件。我们并不关心对象在异步运行的状态，我们只关心success的时候或者error的时候我们要做点我们自己的事情就可以了~

         */

        /*
         发布订阅模式的缺点：

         创建订阅者需要消耗一定的时间和内存。

         虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。

         2. 如何实现发布--订阅模式？

         1. 首先要想好谁是发布者(比如上面的卖家)。

         2. 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。

         3. 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。
            我们还可以在回调函数里面添加一点参数，比如鞋子的颜色，鞋子尺码等信息；
         */

//        简单的发布-订阅模式
        var shoeObj = {};//定义发布者
        shoeObj.list = [];

        //增加订阅者     --  竟然使用静态方法
        shoeObj.listen = function(fn){
            shoeObj.list.push(fn);
        };

        // 发布消息
        shoeObj.trigger = function(){
            for(var i= 0,fn; fn = this.list[i++];){ //这种写法确实有他的简洁之处
                fn.apply(this, arguments);
            }
        };

        //小红订阅如下信息
        shoeObj.listen(function(color,size){
            console.log("颜色是："+color);
            console.log("尺码是："+size);
        });
        // 可可订阅如下信息
        shoeObj.listen(function(color, size){
            console.log("裙子颜色是："+color);
            console.log("耐克尺码是："+size);
        });
//                               颜色是：黑色
//        issueSubscribe.html:66 尺码是：40
//        issueSubscribe.html:70 裙子颜色是：黑色
//        issueSubscribe.html:71 耐克尺码是：40
//        issueSubscribe.html:65 颜色是：白色
//        issueSubscribe.html:66 尺码是：42
//        issueSubscribe.html:70 裙子颜色是：白色
//        issueSubscribe.html:71 耐克尺码是：42

        shoeObj.trigger("黑色",40);
        shoeObj.trigger("白色",42);

        /*
         打印如上截图，我们看到订阅者接收到发布者的每个消息，但是呢，对于小红来说，她只想接收颜色为红色的消息，不想接收颜色为黑色的消息，
         为此我们需要对代码进行如下改造下，我们可以先增加一个key，使订阅者只订阅自己感兴趣的消息
         */

        var clothObj = {};
        clothObj.list = [];

        clothObj.listen = function(key, fn){
            if(!this.list[key]){
                // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表
                this.list[key] = [];        //直接用上 数组的字符串属性。取值的时候也需要用 array[key]
            }
            this.list[key].push(fn);
        };
         //发布消息
        clothObj.trigger = function(){
            var key = Array.prototype.shift.call(arguments);//取出消息类型名称。看人家使用的直接是  shift  而不用 slice（）再【0】
            var fns = this.list[key];   //取出该消息对应的回调函数的集合

            //如果没有订阅该消息，则返回
            if(!fns || fns.length == 0){
                return;
            }
            for(var i= 0,fn;fn=fns[i++];){
                fn.apply(this, arguments);
            }
        };
        //小红订阅的消息
        clothObj.listen("red",function(size){
            console.info("尺码是："+size);
        });
        clothObj.listen("red",function(size){
            console.info("keke裙子的尺码是："+size);
        });
        //keke订阅的消息
        clothObj.listen("block", function(size){
            console.info("可可想要的鞋子尺码："+size);
        });

        clothObj.trigger("red",42);
        clothObj.trigger("block",37);
        clothObj.trigger("hehe",37);


        /*
         3. 发布---订阅模式的代码封装

         我们知道，对于上面的代码，小红去买鞋这么一个对象shoeObj 进行订阅，但是如果以后我们需要对买房子或者其他的对象进行订阅呢，
         我们需要复制上面的代码，再重新改下里面的对象代码；为此我们需要进行代码封装；
         将相同的代码抽离出来 --- 考验功力的时候
         */
        var event = {
            list: [],
            listen: function(key, fn){
                if(!this.list[key]){
                    this.list[key] = [];
                }
                this.list[key].push(fn);
            },
            trigger: function(){
                var key = Array.prototype.shift.call(arguments);    //第一个参数必须是 消息类型
                var fns = this.list[key];
                if(!fns || fns.length == 0){
                    return;
                }
                for(var i= 0,fn;fn=fns[i++];){
                    fn.apply(this,arguments);
                }
            }
        };
        //我们再定义一个initEvent函数，这个函数使所有的普通对象都具有发布订阅功能
        // PS: 这些家伙太厉害了。完全没想到之前的代码是为了铺垫这几行代码的；js 功底还太弱
        var initEvent = function(obj){
            for(var key in event){
                obj[key] = event[key];
            }
        };
        // 我们再来测试下，我们给coatObj这个对象添加发布-订阅功能；
        var coatObj = {};
        initEvent(coatObj);

        // 小红订阅如下消息
        coatObj.listen('red',function(size){
            console.warn("帽子的尺码是："+size);
        });

        // 小花订阅如下消息
        coatObj.listen('block',function(size){
            console.warn("keke喜欢的大衣的尺码是："+size);
        });
        coatObj.trigger("red",40);
        coatObj.trigger("block",42);

        /*
         4. 如何取消订阅事件？

         比如上面的列子，小红她突然不想买鞋子了，那么对于卖家的店铺他不想再接受该店铺的消息，那么小红可以取消该店铺的订阅。
         */
        event.remove = function(key,fn){
            console.info("***火车来了***");
            var fns = this.list[key];
            // 如果key对应的信息没有订阅，则返回
            if(!fns || fns.length == 0){
                return false;
            }
            //如果没有传入fn，则说明key对应的信息全部取消
            if(!fn){
                //fns.length = 0;
            }
            else{
                for(var i=fns.length-1;i>=0;i--){
                    var _fn = fns[i];
                    if(_fn === fn){
                        fns.splice(i,1);    //删除订阅者的回调函数
                    }
                }
            }
        };
        //测试
        var capObj = {};
        initEvent(capObj);

        //小白的订阅消息
        capObj.listen("red",fn1 = function(size){
            console.error("小白喜欢的帽子尺码："+ size)
        });
        capObj.listen("red", fn2 = function(size){
            console.error("小白的帽子更换尺码："+size);
        });
        capObj.remove("red");
        capObj.trigger("red",41);
    </script>

    <script>
        /*
        理解模块间通信
         */
        /*
         我们可以封装一个全局发布-订阅模式对象
         */
        var Event = (function(){
            var list = {},
                    listen,
                    trigger,
                    remove;
            listen = function(key,fn){
                if(!list[key]) {
                    list[key] = [];
                }
                list[key].push(fn);
            };
            trigger = function(){
                var key = Array.prototype.shift.call(arguments),
                        fns = list[key];
                if(!fns || fns.length === 0) {
                    return false;
                }
                for(var i = 0, fn; fn = fns[i++];) {
                    fn.apply(this,arguments);
                }
            };
            remove = function(key,fn){
                var fns = list[key];
                if(!fns) {
                    return false;
                }
                if(!fn) {
                    fns && (fns.length = 0);
                }else {
                    for(var i = fns.length - 1; i >= 0; i--){
                        var _fn = fns[i];
                        if(_fn === fn) {
                            fns.splice(i,1);
                        }
                    }
                }
            };
            return {
                listen: listen,
                trigger: trigger,
                remove: remove
            }
        })();
        // 测试代码如下：
        Event.listen("color",function(size) {
            console.log("尺码为:"+size); // 打印出尺码为42
        });
        Event.trigger("color",42);


//        a.js 负责处理点击操作 及发布消息
        var a = (function(){
            var count = 0;
            var button = document.getElementById("count");
            button.onclick = function(){
                Event.trigger("add",count++);
            }
        })();
        //b.js 负责监听add这个消息，并把点击的总次数显示到页面上来
        var b = (function(){
            var div = document.getElementById("showcount");
            Event.listen('add',function(count){
                div.innerHTML = count;
            });
        })();
    </script>
</body>
</html>