<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>职责链模式</title>
</head>
<body>

    <script>
        /*
         我们可以理解职责链模式是处理请求组成的一条链，请求在这些对象之间依次传递，直到遇到一个可以处理它的对象，
         我们把这些对象称为链中的节点。比如对象A给对象B发请求，如果B对象不处理，它就会把请求交给C，如果C对象不处理的话，
         它就会把请求交给D，依次类推，直到有一个对象能处理该请求为止，
         当然没有任何对象处理该请求的话，那么请求就会从链中离开。
         */

        /*
         天猫每年双11都会做抽奖活动的，比如阿里巴巴想提高大家使用支付宝来支付的话，每一位用户充值500元到支付宝的话，那么可以100%中奖100元红包，

         充值200元到支付宝的话，那么可以100%中奖20元的红包，当然如果不充值的话，也可以抽奖，但是概率非常低，基本上是抽不到的，当然也有可能抽到的。

         我们下面可以分析下代码中的几个字段值需要来判断：

         1. orderType(充值类型)，如果值为1的话，说明是充值500元的用户，如果为2的话，说明是充值200元的用户，如果是3的话，说明是没有充值的用户。

         2. isPay(是否已经成功充值了): 如果该值为true的话，说明已经成功充值了，否则的话 说明没有充值成功；就当作普通用户来购买。

         3. count(表示数量)；普通用户抽奖，如果数量有的话，就可以拿到优惠卷，否则的话，不能拿到优惠卷。
         */
        //一般写代码如下处理
        var order = function(orderType, isPay, count){
            if(orderType == 1){
                if(isPay == true){
                    console.log("亲爱的，您中了100元红包");
                } else {
                    //普通用户处理
                    if(count > 0){
                        console.log("亲爱的，您收到10元红包");
                    } else {
                        console.log("亲爱的，再接再砺");
                    }
                }
            } else if (orderType == 2){
                if(isPay == true){
                    console.log("亲爱的，您中了20元红包");
                } else {
                    //普通用户处理
                    if(count > 0){
                        console.log("亲爱的，您收到10元红包");
                    } else {
                        console.log("亲爱的，再接再砺");
                    }
                }
            } else if (orderType == 3){
                //普通用户处理
                if(count > 0){
                    console.log("亲爱的，您收到10元红包");
                } else {
                    console.log("亲爱的，再接再砺");
                }
            }
        };
        //上面的代码虽然可以实现需求，但是代码不容易扩展且难以阅读，假如以后我想一两个条件，我想充值300元成功的话，
        // 可以中奖150元红包，那么这时候又要改动里面的代码,这样业务逻辑与代码耦合性相对比较高，一不小心就改错了代码

        //利用职责模式实现
        function order500(orderType, isPay, count){
            if(orderType == 1 && isPay == true){
                console.log("keke,你抽中了100元红包");
            } else {
                //自己不处理，传递给下一个对象 order200 去处理
                order200(orderType, isPay, count);
            }
        }
        function order200(orderType, isPay, count){
            if(orderType == 1 && isPay == true){
                console.log("keke,你抽中了20元红包");
            } else {
                //自己不处理，传递给下一个对象 orderNormal 去处理
                orderNormal(orderType, isPay, count);
            }
        }
        function orderNormal(orderType, isPay, count){
            //没有充值的情况，当做普通用户处理
            if(count > 0){
                console.log("keke,你抽中了10元红包");
            } else {
                console.log("keke,再接再砺");
            }
        }
        //上面的代码虽然可以当作职责链模式，但是我们看上面的代码可以看到order500函数内依赖了order200这样的函数，
        // 这样就必须有这个函数，也违反了面向对象中的 开放-封闭原则。下面我们继续来理解编写 灵活可拆分的职责链节点。


        function order_500(orderType, isPay, count){
            if(orderType == 1 && isPay == true){
                console.log("keke,你抽中了100元红包");
            } else {
                //我不知道下一个节点是谁，反正把请求往后传递
                return "nextSuccessor";
            }
        }
        function order_200(orderType, isPay, count){
            if(orderType == 2 && isPay == true){
                console.log("keke,你抽中了20元红包");
            } else {
                //我不知道下一个节点是谁，反正把请求往后传递
                return "nextSuccessor";
            }
        }
        function order_Normal(orderType, isPay, count){
            //没有充值的情况，当做普通用户处理
            if(count > 0){
                console.log("keke,你抽中了10元红包");
            } else {
                console.log("keke,再接再砺");
            }
        }
        // 下面需要编写职责链模式的封装构造函数方法
        var Chain = function(fn){
            this.fn = fn;
            this.successor = null;
        };
        Chain.prototype = {
            setNextSuccessor: function(successor){
                return this.successor = successor;
            },
            passRequest: function(){
                var ret = this.fn.apply(this, arguments);
                if(ret == "nextSuccessor"){
                    return this.successor && this.successor.passRequest.apply(this.successor, arguments);   //绑定this.successor;只写this 会出错的
                }
                return ret;
            }
        };
        //现在我们把3个函数分别包装成职责链节点：
        var chainOrder500 = new Chain(order_500);
        var chainOrder200 = new Chain(order_200);
        var chainOrderNormal = new Chain(order_Normal);

        // 然后指定节点在职责链中的顺序
        chainOrder500.setNextSuccessor(chainOrder200);
        chainOrder200.setNextSuccessor(chainOrderNormal);

        //最后把请求传递给第一个节点：
        chainOrder500.passRequest(1,true,500);  // 亲爱的用户，您中奖了100元红包了
        chainOrder500.passRequest(2,true,500);  // 亲爱的用户，您中奖了20元红包了
        chainOrder500.passRequest(3,true,500);  // 亲爱的用户，您已抽到10元优惠卷
        chainOrder500.passRequest(1,false,0);   // 亲爱的用户，请再接再厉哦
    </script>
</body>
</html>