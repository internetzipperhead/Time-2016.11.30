<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>阿森纳—兵工厂</title>
    <link rel="stylesheet" href="../lib/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../css/index.css"/>
    <link rel="stylesheet" href="../css/oop.css"/>
    <script type="text/javascript"></script>
</head>
<body>
    <script src="../lib/jquery-1.12.1.min.js"></script>
    <script src="../js/Interface.js"></script>
    <script>

        var BicycleShop = function(name){
            this.name = name;
            this.method = function(){
                return this.name;
            }
        };
        BicycleShop.prototype = {
            constructor: BicycleShop,

            sellBicycle: function(model){
                var bicycle = new this.createBicycle(model);
                console.log(bicycle);
                //执行A业务
                bicycle.A();
                //执行B业务
                bicycle.B();

                return bicycle;
            },
            createBicycle: function(model){
                throw new Error("父类是抽象类不能直接调用，需要子类重写该方法");
            }
        };

        var meilida = new BicycleShop("美利达");
        console.log(meilida);

        function extend(subClass, supClass){
            var F = function(){};
            F.prototype = supClass.prototype;

            subClass.prototype = new F();
            subClass.prototype.constructor = subClass;
            subClass.supClass = supClass.prototype;
            if(supClass.prototype.constructor === Object.prototype.constructor){
                supClass.prototype.constructor = supClass;
                //检查超类型的构造器是否为原型自身
            }
        }

        var BicycleChild = function(name){
            this.name = name;
//            BicycleChild.superClass.constructor.call(this, name);
            BicycleShop.call(this, name);
        };

        extend(BicycleChild, BicycleShop);  //马丹，就是一个函数先后顺序的问题啊。自己太愚蠢了

        //子类重写父类的方法
        BicycleChild.prototype.createBicycle = function(mama){
            var A = function(){
                console.log("执行A操作任务");
            };
            var B = function(){
                console.log("执行B操作任务");
            };
            return {
                A: A ,
                B: B
            }
        };

        var bicycleChild = new BicycleChild("吉安特");

        /**
         * 下面是一个简单函数封装的例子
         * 重点在于，可以很好的隐藏我们的name，age。外部不能访问到我们的私有变量和函数
         * 而且，外部定义的代码W，S，在每一次实例new的时候，只保存一份，不会造成内存浪费的问题
         * 所以，可以将我们的一些判断逻辑或者其他的逻辑写在外面，变成一个静态方法
         * 私有变量会一直保存，因为是在一个闭包中，不会立即消失
         */
        var Angel = (function(_name,_age){
            //私有方法，外面访问不到
            var west = "life";
            //time等于一个私有的静态变量。
            var time = 0;
            //私有函数
            var W = function(){
                console.log("you are pulled from the wreckage 你自空想的沼泽中被拉出")
            };
            var S = function(){
                console.log("You will always be my   你永远是我的")
            };
            return function(_name, _age){
                var name, age;
                this.setName = function(_name){
                    name = _name;
                };
                this.setAge = function(){
                    age = _age;
                };
                this.say = function(){
                    console.log( name+" is listening the song of " + west);
                };
                this.tell = function(){
                    S();
                };
                this.setName(_name);
                this.setAge(_age);
                time++;
                if(time>3) throw new Error("对象的实例只能有三分");
                console.log(this);
            }
        })();
        var xing = new Angel("xing",45);
        var xing = new Angel("唐僧",45);
        var xing = new Angel("猪八戒",345);
        var xing = new Angel("孙猴子",545);
        console.info(xing);


    </script>
</body>
</html>